## 一、数据结构定义

### 1. **节点数据结构 (PNode)**
```typescript
interface PNode {
  id: string;           // 节点唯一标识符
  name: string;         // 节点标题
  description: string;  // 节点描述
  parent?: string;      // 父节点ID（空字符串表示根节点）
  children: string[];   // 子节点ID列表
  nexts: string[];      // 后续节点ID列表（同一层次）
  prevs: string[];      // 前驱节点ID列表（同一层次）
  expanded?: boolean;   // 是否展开子图内容
  // ... 其他业务字段
}
```

### 2. **图数据结构 (PGraph)**
```typescript
interface PGraph {
  id: string;                    // 图唯一ID
  name: string;                  // 图名称
  rootNodeIds: string[];         // 多根支持（DAG可能有多个入口）
  nodes: Record<string, PNode>;  // 扁平化节点映射
  // ... 其他业务字段
}
```

## 二、布局核心规则

### 1. **层次关系规则**
- **父子关系**：`parent`/`children` 表示垂直嵌套层次
- **边关系**：`nexts`/`prevs` 表示水平流向关系
- **一个节点可以同时是子节点和父节点**

### 2. **边约束规则**
- **边严格限制在 `parent` 相同的节点之间**
- **不能跨层次连接**：不同父节点下的节点不能有边连接
- **子图隔离**：不同子图的节点之间不能有边

### 3. **展开/折叠规则**
- `expanded = true`：显示并布局子图内容
- `expanded = false`：跳过子图布局，使用默认大小
- 默认大小：`[120, 60]`

## 三、布局算法逻辑

### 1. **算法流程**
```
1. 按 parent 字段分组节点 → 形成子图集合
2. 建立子图依赖关系（嵌套关系）
3. 深度优先递归布局：
   a. 先布局最深层的子图
   b. 逐层向上布局父图
4. 计算全局偏移量
5. 更新边的 zIndex
```

### 2. **子图布局逻辑**
```typescript
// 对于每个子图：
if (子图对应的节点.expanded === false) {
  // 使用默认大小，不布局子节点
  size = [defaultWidth + margin*2, defaultHeight + margin*2];
} else {
  // 使用 dagre 布局算法
  // 1. 创建 dagre 图
  // 2. 添加节点（考虑 expanded 状态的大小）
  // 3. 添加边（验证 parent 相同）
  // 4. 执行 dagre.layout()
  // 5. 收集布局结果
}
```

### 3. **依赖关系建立**
- 如果子图A包含节点X，且节点X是子图B的ID
- 那么子图B是子图A的依赖（B嵌套在A中）
- 布局顺序：先布局依赖的子图（深度优先）

## 四、性能优化要求

### 1. **并行计算**
- 使用 Web Workers 实现多线程
- 独立子图可以并行布局
- 主线程负责协调和结果合并

### 2. **缓存机制**
- 节点大小缓存
- 布局结果缓存
- 依赖关系缓存

### 3. **增量更新**
- 只更新变化的部分
- 避免全量重新布局

## 五、边界条件处理

### 1. **循环依赖检测**
- 防止无限递归
- 最大递归深度限制

### 2. **错误处理**
- 无效边的过滤（跨层次边）
- 缺失节点的处理
- Worker 失败降级方案

### 3. **内存管理**
- Worker 池管理
- 大数据集分块处理
- 及时释放内存

## 六、技术栈要求

### 1. **核心依赖**
- dagre.js：DAG布局算法
- Web Workers：并行计算
- TypeScript：类型安全

### 2. **性能目标**
- 支持大规模嵌套图（1000+节点）
- 布局时间 < 1秒（中等规模图）
- 内存使用优化

## 七、关键设计决策

### 1. **分离关注点**
- 图结构分析
- 布局计算
- 结果合并

### 2. **可扩展性**
- 支持不同的布局算法
- 支持自定义布局参数
- 支持插件化扩展

### 3. **兼容性**
- 与现有代码兼容
- 渐进式升级
- 降级方案

## 八、使用示例

```typescript
// 创建布局实例
const layout = new ParallelNestedDagreLayout({
  rankdir: 'TB',
  align: 'UL',
  ranksep: 50,
  nodesep: 50,
  workerCount: 4
});

// 执行布局
const layoutModel = await layout.execute(graphData);

// 渲染到画布
graph.read(layoutModel);
```

这个总结涵盖了数据结构定义、布局规则、算法逻辑、性能优化要求等核心内容，可以作为技术文档保存记录。
